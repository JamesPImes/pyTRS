# Guide to `TractWriter`

The `TractWriter` class is a wrapper for the built-in `csv.writer` with added methods for the streamlined writing of consistent `Tract` data to .csv files. It writes a single row for each `Tract` object and will accept any number of `Tract`, `PLSSDesc`, and/or `TractList` objects.

It is not imported with `pytrs` by default.

```
import pytrs
from pytrs.tractwriter import TractWriter
```

(Examples in this guide will import the `TractWriter` class directly, rather than the `pytrs.tractwriter` package.)

## Creating a `TractWriter` object

At the most basic, we need to specify:

 *  which [data fields (i.e. attributes)](https://github.com/JamesPImes/pyTRS/blob/master/guides/guides/tract_attributes.md#tract-attribute-table) we want for each `Tract` object that gets written (`attributes=[<list of attribute names>]`).
 
 * the filepath we want to write to (`fp=<path>`).
 
 * `mode=<'w' or 'a'>` to decide if we're overwriting or appending existing files at `fp` (same purpose and effect as in the built-in `open(file, mode, <...>)` function).
```
import pytrs
from pytrs.tractwriter import TractWriter

tract_writer = TractWriter(
    attributes=['trs', 'desc', 'lots', 'qqs', 'flags'],
    fp='tract_data.csv',
    mode='w')
```

Other options at init:

|Parameter              | Explanation                                                  | Required |Footnote |
|:----------------------|:---------------------------------------------------|:----------:|:-------:|
| `attributes` | a list of attribute names of `Tract` objects  | x | 1 |
| `fp`         | the filepath to write to | x | | 
| `mode=<'w' or 'a'>` | `'w'` to overwrite existing file, or `'a'` to append to an existing file | x | 2 |
| `nice_headers=<bool, list, or dict>` | use custom headers (see footnote)   | | 5 |
| `plus_cols=<list>` | Headers for additional columns we intend to write | | 3 |
| `uid=<int>`       | The number at which to start for unique ID numbers | | 4 |


Footnotes:
1) These attributes will be included on every row written by this `TractWriter` object.

2) If in `mode='a'` and a file exists at `fp`, then headers will not be written.

3) Include a list of headers in `plus_cols=` if we intend to write additional data for every row that is not included among the `Tract` attributes. (We will have to specify what data to write every time.)

4) If `uid=` is not specified, then unique ID's will not be generated or written. If opening our file in `mode='a'`, we may want to start at some number higher than `1` -- in which case, we can specify that here. UID's will increment every time `.write()` gets called. ([See below](https://github.com/JamesPImes/pyTRS/blob/master/guides/guides/tractwriter.md#unique-id-numbers) for the format of unique ID's generated by pyTRS.)

5) `nice_headers` defaults to `False` (i.e. just use the attribute names themselves as headers). Alternatively, may pass any of the following:

* a dict keyed by attribute name, whose values are the headers to use. (Any missing keys will result in using the attribute name itself.)

* a list of headers to use. (Should be equal in length to the list passed as ``attributes``, but will not raise an error if that's not the case. The resulting column headers will just be fewer than the actual number of columns.)

* pass as `True` to use the values in the `pytrs.Tract.ATTRIBUTES` dict for headers.

```
import pytrs
from pytrs.tractwriter import TractWriter

custom_headers = {
    'trs': 'Twp/Rge/Sec',
    'desc': 'Description',
    'lots': 'Lots',
    'qqs': 'Aliquots',
    'flags': 'Error/Warning Flags'
    'source': 'Document Number'
}

tract_writer = TractWriter(
    attributes=['trs', 'desc', 'lots', 'qqs', 'flags'],
    fp='tract_data.csv',
    mode='w',
    nice_headers=custom_headers,
    plus_cols=['Document Date'],
    uid=1)
```

## Writing `Tract` data with `.write()`

Once a `TractWriter` has been created, all we have to do is call `.write()`, which takes a `to_write` argument, which should be a `Tract`, `PLSSDesc` or `TractList` object, or a collection of any of those objects.

```
import pytrs
from pytrs.tractwriter import TractWriter

tract_writer = TractWriter(<...>)


# Example writing Tracts in a single PLSSDesc object.
some_plssdesc = pytrs.PLSSDesc(
    'T154N-R97W Sec 14: NE/4, Sec 15: W/2', parse_qq=True)
tract_writer.write(some_plssdesc)


# Example writing Tracts in a batch of PLSSDesc objects.
raw_descriptions = [<large list of raw PLSS land descriptions as strings>]
for description in raw_descriptions:
    loop_plssdesc = pytrs.PLSSDesc(description, parse_qq=True)
    tract_writer.write(loop_plssdesc)
```

`.write()` returns an integer, being the total number of rows that were written during that call.


### Include custom data with the `plus_col=[]` argument

To write additional columns beyond the `Tract` data, use the argument `plus_col=[]` (which takes a list of data to write -- one column per element in the list).

```
tract_writer = TractWriter(
    attributes=['trs', 'desc', 'lots', 'qqs', 'flags', 'source'],
    fp='tract_data.csv',
    mode='w',
    plus_cols=['Document Date'],
    uid=1)

# Some dummy data in a nested dict.
doc_dict = {
    'Doc_123456': {
        'date': '12-01-2004',
        'descrip': 'T154N-R97W Sec 14: NE/4, Sec 15: W/2'
    },
    
    'Doc_678910': {
        'date': '04-02-2005',
        'descrip': 'T154N-R97W Sec 1: Lots 1 - 3, S/2NE/4'
    },
    # <etc.>
}

for doc_num, doc_info in doc_dict.items():
    description_to_parse = doc_info['descrip']
    doc_date = doc_info['date']
    parsed = pytrs.PLSSDesc(
        description_to_parse, source=doc_num, parse_qq=True)
    
    # Write the contents of each PLSSDesc object, and also a column for
    # the document date from the dict.
    tract_writer.write(parsed, plus_cols=[doc_date])
```

Note that this does not place any restrictions on aligning the `.write(<...>, plus_cols=[DATA])` to headers (if any) created in `TractList(<...>, plus_cols=[HEADERS])`. Use care to keep your custom columns aligned.


### Unique ID numbers

Optionally turn on unique ID numbers when the `TractList` is created by passing `uid=<int>`. UID's increment every time `.write()` is called (unless an error is raised).

UID's in pyTRS are strings and take the format `'<major>.<minor>-<minor total>'` -- e.g., `'0027.a-d'` (the example below will clarify).

For example, assume we __started__ our first UID at `uid=1` (as set when this `TractWriter` was created); and we have called `.write()` 26 times so far. So our next UID will be 27.

We have just parsed a `PLSSDesc` object (stored as variable `some_plssdesc`), which now contains 4 new `Tract` objects.

Thus, when we call `our_tract_writer.write(some_plssdesc)`, the 4 new rows will have these UID's:
 ```
 '0027.a-d'  # 1st of four new rows written
 '0027.b-d'  # 2nd of four new rows written
 '0027.c-d'  # 3rd of four new rows written
 '0027.d-d'  # 4th and final of four new rows written
```

A few misc. points:
* Letters will roll over to doubles after 26 -- i.e. `27th new row -> 'aa'`, `'28th new row -> 'ab'`, etc.

* The letters reset to `'a'` upon ever new call to `.write()`.

* To configure how many places to justify the digits, assign any non-negative integer to the `.uid_just` attribute for the `TractWriter` (defaults to `4`, as in the example above).

* Check the UID integer that will be used next in the `.uid` attribute.

* Setting `.uid` after the fact will not turn on UID's. To do that, set the `.gen_uids` attribute to `True`.
